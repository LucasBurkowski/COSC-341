/**
 * Copyright (c) 2007 .
 * All rights reserved.
 *
 * Please read the LICENSE file for license information.
 *
 * This is the class that generates the ??? syntax. 
 */

package iota.compiler;

import iota.node.*;
import iota.analysis.*;

import java.util.*;
import java.io.*;

public class CodeGenerator extends DepthFirstAdapter {
	
  private Hashtable lcl_table = new Hashtable();

  // this variable stores the name of the iota source file
  private String source;
  private String code_name;

  //PrintWriter out;
  PrintStream out = System.out;

  public CodeGenerator(String source) {
    this.source = source; // name of the source file to be processed

    // class name of the file to be generated
    code_name = source.substring(0, source.length() - 4);

    // create an instance of the PrintWriter class whose destination
    // filename is <class_name>.x
   /* try{
      out = new PrintWriter(
            new BufferedWriter(
              new FileWriter(code_name + ".x")));
     }
     catch(IOException exc) {
       System.out.println(exc);
     }
	*/
  }

  public void inAProgram(AProgram node) {
    // write some comments at the top of the file
    System.out.println("# This file was generated by iota compiler.");
    System.out.println(); // leave a space

    // generate the object file headings
    // this indicates the source from which the file was compiled
    System.out.println("# source " + source);
    System.out.println("# machine code follows ... \n");

	out.println ("main\tentry\t$$1");
  }

  public void outAProgram(AProgram node) {
	
	out.println ("\treturn");
	out.println ("$$1\tequ 2\t\t\t; main");
	out.println ("end\t1, main\n");
  }

  public void outASingleIdentifierList(ASingleIdentifierList node) {
	String key = node.getIdentifier().getText();

    // store the variable in the symbol table for later reference
    int p_val = lcl_table.size();
	lcl_table.put(key, new Integer(p_val));
  }

  public void outAMultipleIdentifierList(AMultipleIdentifierList node) {
	String key = node.getIdentifier().getText();

    // store the variable in the symbol table for later reference
    int p_val = lcl_table.size();
	lcl_table.put(key, new Integer(p_val));
  }
  
  public void outANumberFactor(ANumberFactor node) {	
	out.println("\tload\tcon," + node.getNumber().getText());

  }

  public void outAIdentifierFactor(AIdentifierFactor node) {
	String key = node.getIdentifier().getText();

    // get the image of the variable
    int p_val = ((Integer) lcl_table.get(key)).intValue();
		
	out.println("\tload\tlcl," + p_val + "\t\t; " + key);

  }

  public void outAAssignmentStatement(AAssignmentStatement node) {
	String key = node.getIdentifier().getText();

    // get the image of the variable
    int p_val = ((Integer) lcl_table.get(key)).intValue();
	
	out.println("\tstore\tlcl," + p_val + "\t\t; " + key);
	out.println("\tpop\t\t\t; clear stack");
  }

  public void outAPlusExpression(APlusExpression node) {
	out.println("\talu\t+\t\t; +");
  }
  public void outAMinusExpression(AMinusExpression node) {
	out.println("\talu\t-\t\t; -");
  }
  public void outAMultTerm(AMultTerm node) {
	out.println("\talu\t*\t\t; *");
  }
  public void outADivTerm(ADivTerm node) {
	out.println("\talu\t/\t\t; /");
  }

  public void inADisplayStatement(ADisplayStatement node) {
	String key = node.getIdentifier().getText();

    // get the image of the variable
    int p_val = ((Integer) lcl_table.get(key)).intValue();

	out.println("\tload\tlcl,"+ p_val +"\t\t; " + key);
    out.println("\tdisp");
  }
}
